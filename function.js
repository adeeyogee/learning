//! Функция - код + его окружение
//Функция может представиться. как контейнер для нескольких действий. Функция - блок кода, который можно выполнять многократно с разными вводными значениями. (параметры)

//Функции бывают:
// - именованные (function sum (a,b) {})
// - присвоена переменной
// - анонимная (function (a,b) {})
// - аргументом при вызове другой функции (CALLBACK)
// - значением метода объекта
// - стрелочные (упрощенный синтаксис из обновления 2015 года () =>)


// Существует несколько правил работы с функциями:
// - 1) одна функция - одно действие,
// - 2) не менять значение глобальных переменных внутри функции
// - 3) не рекомендуется внутри функции присваивать значения НЕ объявленным переменным. 

/*
let i = 1
console.log(i)
alert('Hello')
 это набор действий, которые будут выполняться друг за другом.
 Однако нам может потребоваться вывести данные значения снова. Тогда лучше воспользоваться функцией. 
 Это своего рода контейнер. в который мы кладем набор действий и алгоритмов. После чего, мы вызываем данный "контейнер", когда нам это необходимо
function doSomething () {
    let d = 2
console.log(d)
alert('Privet')
} 
console.log(doSomething);
*/

//*Имя функции должно быть глаголом, с припиской того, над чем выполняется действие




//@ТИПЫ ФУНКЦИЙ
// func expression - объявление функции в контексте какого-либо присваивания или другого выражения. Функциональное выражение. (const a = function (x) {}). Нельзя использовать автономно (просто так взять и вызвать). Можно присваивать переменной. Можно использовать как аргумент для другой функции (Callback. И это будет правильно). Нельзя использовать до объявления. Хостинг не срабатывает

// func declaration - функция объявленная в основном потоке кода. Обычное объявление функции (function checkAge (age) {}). Функция с именем. Используем, когда планируем вызывать эту функцию по имени. Можно присваивать переменной. Можно использовать как аргумент для другой функции (Callback. Хотя обычно используют анонимную функцию). На такой тип функции распространяется хостинг и такая функция может быть вызвана до момента ее объявления.


function greet(name){
    console.log('Привет - ', name)
}


greet('Vlad')



// Тип функции Function declaration - можно вызвать в любой части кода (в т.ч. и до создания самой функции)

const greet2 = function greet2(name) {
    console.log('Привет 2 - ', name)
}
greet2('secondName')
//Тип функции Function expression - нельзя вызывать функцию, до момента ее создания






//@СТРЕЛОЧНЫЕ ФУНКЦИИ

// (a, b) => {} - базовый синтаксис СФ. В примере ниже мы присваиваем эту функцию переменной, чтобы можно было вызвать. Хостинг не срабатывает

// сокращение синтаксиса стрелочных функций

// 1) a => {} - если у СФ один параметр, то круглые скобки можно опустить. но лучше оставить для наглядной читабельности кода.
// 2) (a, b) => a + b Если СФ имеет только одно вычисление, то можно записать без фигурных скобок. Следует учесть, что такая форма записи сразу же вернет результат автоматически ( без директивы return ) (НЕЯВНЫЙ ВОЗВРАТ ЗНАЧЕНИЯ)
/*
const myFun = (a, b) => {
    let c
    a +=1;
    b -=2;
    c = a + b;
return c
}

console.log(myFun(10, 2))

//! Стрелочные функции НЕ получают своего ключевого слова this
*/

//@ЧИСТЫЕ ФУНКЦИИ

// первый критерий чистой функции: при введении одного и того же параметра, всегда получаем один и тот же результат 
// второй критерий - отсутствие side эффектов при обращении к функции (выведение на страницу, выведение в консоль, запись логов и т.д.)
//если система меняется после запуска функции, значит есть каки-то побочные эффекты, который функция выполняет

//?Пример чистой функции

/*
function a(b) { 
    return b*5
}
*/



//? Пример функции, которая зависит от внешних обстоятельств (переменной с)
/*
let c = 5
function a(b) { 
    return b*c
}
*/

//? преимущества чистых функций:
//1. Потенциально уменьшает количество багов,т.к. не влияет на систему
//2. Легче тестируются
//3. Легче для понимания и для читаемости кода


//@ПАРАМЕТРЫ ПО УМОЛЧАНИЮ
/*
const sum = (a, b = 1) => a + b //был использован параметр по умолчанию b=1. Если при вызове функции, не  указывается параметр b, то его значение применяется по умолчанию
console.log(sum(41)) // 42.  Был передан только аргумент а. b - у нас указан по умолчанию = 1
Вместо выражения b = 1 может быть функция (Например, const sum = (a, Date() )  - встроенная функция, которая возвращает текущую дату

*/

//Пример использования функции Date() в виде параметра по умолчанию.

//Создаем объект с которым будет работать. Объектов в коде может быть много.
/*
const myObject = {
    name: 'firstName',
    secondName: 'secondName',
    middleName: 'middleName'
}
Создаем функцию, первым параметром которой будет один из наших объектов
const myFunction = (person,addedAt = Date()) => ({
    ...myObject,
    addedAt: addedAt
})

console.table(myFunction())

*/
//ВНЕШНИЕ И ВНУТРЕННИЕ ПЕРЕМЕННЫЕ

//Функция имеет доступ к внешним переменным
/*
let friend = 'Sergei'
function bestFriend (){
    console.log('близкий мне друг,', friend)
}
bestFriend()
*/
// данная функция получила доступ к переменной извне

// ЛОКАЛЬНЫЕ ПЕРЕМЕННЫЕ

/*
function message () {
    let a1 = 'Hello!'
    alert(a1) // Внутренняя(локальная переменная)
}
message()
alert(a1) // not defined. Обычная переменная, которая не назначена
*/


//@АРГУМЕНТЫ ФУНКЦИИ (ПАРАМЕТРЫ)
/*
function showMessage (from, text) { //добавляем функции 2 параметра
    console.log(from + text) //говорим, что с этими параметрами функция будет делать
}
showMessage('People',  ', hello') //подставляем на место параметров любые наши значения
Передаваемые значения копируются в параметры функции и становятся локальными
переменными.
*/

//@ДИРЕКТИВА RETURN


//Функция всегда возвращает значение. Если return отсутствует, то функция вернет undefined

/*

    function newSum (f, g){
        return f + g; //директива завершает действие функции и возвращает значение в ВЫЗВАВШИЙ ЕЕ КОД (в этом случае это: let newResult = newSum(2,4) - данная конструкция вызывает функцию)
    }
    let newResult = newSum(2, 4)
console.log(newResult)

*/

//return может быть несколько (к примеру, с использование конструкции if,else)
//return сразу завершает работу функции


/* return 
(some + long + expression + or + whatever * f(a) + f(b))
такой вывод не корректен, т.к. JS воспримет это как просто return
Если требуется сделать длинное выражение в return, то записывать нужно след образом
*/
/*
return (
some + long + expression
+ or +
whatever * f(a) + f(b)
)
*/
//___________________________________

//ДЕСТРУКТУРИЗАЦИЯ ПАРАМЕТРОВ ФУНКЦИИ
// иногда функция получает объект в качестве параметра. И нас будут интересовать определенные свойства объекта, не все
// Сама Д происходит в первой строке объявления функции. В качестве параметров, мы передает свойства объекта, которые хотим Д
// Когда вызываем функцию, то в качестве аргумента передаем объект, а функция уже будет подставлять в параметры те свойства объекта, которые мы прописали в скобках
/*
const userData = {
    fName: 'Greg',
    sName: 'Johnson',
    age: 16,
    commentsQty: 42,

}
console.log(userData)

function userInfo ({fName, sName, commentsQty}) {
    if (!commentsQty) {
        return `User ${fName} ${sName} has no comments` 
    }
    return `User ${fName}  ${sName} has ${commentsQty} comments`
}
console.log(userInfo(userData)) //User Greg  Johnson has 42 comments
*/
//___________________________________

//@ ЗАМЫКАНИЯ (Closures)
// Замыкание - это такое явление, при котором определенная, нужная нам область видимости замыкается на переменную
// Замыкание - это не сущность, как объект или массив. Замыкание - это особенность функции. Такая особенность возникает благодаря тому, что сама по себе функция - это код + НАБОР ОКРУЖАЮЩИХ ЕЕ ДОСТУПНЫХ ДАННЫХ

/*
function counter() {
    let a = 0
    return function() {
       a++
       console.log(a)
    }
 }
 
 const d = counter()
 d()
 d()

 */

 // В данном примере произошло замыкание вложенной функции и доступных для нее данных (let a = 0) на переменную d
 // Таким образом, мы создаем переменную для подсчета суммы не в глобальной области видимости, а в замыкании. Это защищает переменную от внешнего воздействия и последующих багов.


//? Замыкание - возможность языка создавать приватный контекст для сущностей js
// Еще пример замыкания

function User(defaultName) {
    let _name = defaultName
  
    return {
        getName () {
            return _name
        },
  
        setName (n) {
            return _name = n
        }
    }
  }
  
  const user = User('firstName')
  
  console.log(user) 
  // Если мы просто обратимся к функции, то увидим там 2 метода. Поле переменная name будет нам недоступна
  
  console.log(user.getName()) 

  // В данном примере есть функция User, которая возвращает объект из 2х методов. А сам объект имеет в своем окружении (контексте) переменную name. 
// Таким образом, мы спрятали переменную name в приватную область видимости, в контекст объекта
  // Если обратимся непосредственно к методу, то увидим значение переменной name.
  //! Т.е. мы сами определили метод, который будет взаимодействовать с переменной. А могли этого и не делать, чтобы полностью защитить name
  
  
  user.setName('changeName') // Также, мы добавили метод, который позволяет менять значение переменной. 
  console.log(user.getName())
//___________________________________



//ЛОГИКА ФУНКЦИИ



/*
function checkAge (age){
    if (age>18) {
        return true
        //объявляем функцию с названием checkAge и параметром age (checkAge - название функции,а age - то,что функция будет вычислять)
        //Говорим, что если у нас вычисляемый параметр age больше 18, то функция возвращает true
    } else {
        return confirm('А родители разрешили?')
        // формулировка else говорит, о том, что все остальные значения, которые не относятся к утверждению age>18, будут выводить дополнительное окно с текстом.
    }
}
let age = prompt('Сколько вам лет?')
//в одной строке мы объявляем переменную age (мы могли это сделать еще перед функцией, а потом уже написать age = prompt....., но сделали это в одной строке, для оптимизации кода)
// выводим окно с вопросом, где ответ от пользователя сразу помещается в переменную age (а наша функция будет эту переменную высчитывать)

if (checkAge(age) ){
    alert('Доступ получен')
    //теперь мы просто спрашиваем про переменную age в и позволяем сработать функции, которую мы написали выше. Пользователь вводит значение age и автоматические срабатывают условия в нашей функции
} else {
    alert('Доступ закрыт')
}
document.querySelector('.out').innerHTML = age

*/



//@CALLBACK функции.


// Позволяют нам отсрочить выполнение функции. При чем отсрочить не по времени,а до определенного события.

/*
function done(){
    console.log('Пока все понятно!');
} // 1) Создаем функцию, которую хотим призвать в виде Callback. т.е. эта функция - что-то вроде переменной, которую мы будем дальше вызывать

function learnJS (lang, CALLBACK) {
    console.log (`Я изучаю: ${lang}`);
    CALLBACK();
} // 2) Пишем теперь функцию с Коллбеком. Тело функции должно включать название аргумента в виде функции. т.е., если в параметр функции мы заносит call, то и в теле функции также необходимо писать call(). Таким образом, резюмируя: мы подразумеваем, что в нашей основной функции learnJS один из параметров будет другая функция ( и в теле мы это указываем)

*/

//learnJS('JavaScript', done); //Несмотря на то, что, по сути, done - тоже функция, ее мы вызываем без (). Такова особенность синтаксиса Callback функций.

// 3) Теперь вызываем нашу основную функцию и в качестве аргумента передаем нашу первую функцию, которая была объявлена заранее.

//Как видно, при вызове learnJS, первым аргументом мы передаем данные для нашей первичной функции. А второй аргумент (который изначально мы присвоили CALLBACK, мы передаем тот код(функцию), которую хотим вызвать, после срабатывания основной функции)






// ПРИМЕР МУТАЦИИ ОБЪЕКТА ЧЕРЕЗ ФУНКЦИЮ
/*
const testObject = {
    age: 21,
    name: 'Boris'
}

function increasePersonAge (person) {
    person.age +=1;
    return person
}

increasePersonAge(testObject.age) // 22
// не было создано копии объекта и мы просто обратились к ключу по ссылке

// ВНУТРИ ФУНКЦИИ НЕ РЕКОМЕНДУЕТСЯ МЕНЯТЬ ВНЕШНИЕ ОБЪЕКТЫ !!!! Для этого внутри функции создаются копии объектов
// Пример, как сделать копии объекта через функцию

function newIncreasePersonAge (person2) {
    const updatedPerson = Object.assign({}, person2)
    updatedPerson.age +=1
    return updatedPerson
}

const testObject2 = newIncreasePersonAge(testObject)
console.log(testObject)
console.log(testObject2)
//В результате мы скопировали объект и нем изменили необходимое в нем свойство
//Object { age: 21, name: "Boris" }
//Object { age: 22, name: "Boris" }
*/

