//События
//Чтобы использовать событие,необходимо назначить обработчик (функция)
//Есть три способа создать событие 

//1) в самом файле html 
//<button onclick="alert('hello')" id="btn"></button> При чем само событие называется click и добавляется приставка on
//также необходимо комбинировать кавычки. Использовать разные символы, чтобы программа не запустилась
// Такой метод обычно не используется, либо для совсем незначимых, мелких событий или тестов.

//2) Через свойство DOM дерева
/*const btn = document.querySelector('button')
btn.onclick = function() {
    alert('hi');
}
*/
//Есть нюанс: если повторять такие обработчики несколько раз, то предыдущий уже работать не будет
// К тому же, такой метод уже не получится программно удалить в случае необходимости.

//3) addEventListener()
//самый адекватный способ. js будет следить за элементом и ждать событие, которое мы назначим. Как только событие возникнет - js запустит обработчик события
/*
btn.addEventListener('click', () => { //callback функция. сначала выполнится клик от пользователя,а потом уже функция↓↓↓
    alert('Click')
})
*/

//поддерживает дублирование событий, которые будут выполняться друг за другом

document.querySelector('.b1').onclick = function (e) { //САМО СОБЫТИЕ - ЭТО ОБЪЕКТ, КОТОРЫЙ ИМЕЕТ РЯД СВОЙСТВ. МЫ МОЖЕМ ПЕРЕДАТЬ В ФУНКЦИЮ ПАРАМЕТР EVENT И ПОЛУЧИТЬ ДОСТУП К ЭТИМ СВОЙСТВАМ
    //Т.Е, ПЕРВЫМ АРГУМЕНТОМ ВСЕГДА БУДЕТ ОБЪЕКТ "СОБЫТИЕ". НАЗЫВАТЬ МЫ ЕГО МОЖЕТ КАК УГОДНО. (Е, EVENT, X - БЕЗ РАЗНИЦЫ.) СЛЕДУЕТ ПОНЯТЬ, ЧТО ПРИ ТАКОМ СИНТАКСИСЕ В КОЛБЕК ФУНКЦИИ ПЕРВЫМ АРГУМЕНТОМ ВСЕГДА БУДЕТ ОБЪЕКТ "СОБЫТИЕ"
    //ЧЕРЕЗ ЗАПЯТУЮ МЫ МОЖЕМ ДОБАВИТЬ И ДРУГИЕ АРГУМЕНТЫ, С КОТОРЫМИ НАМ НАДО РАБОТАТЬ
    console.log(e)
}
//!ВАЖНО. Свойства события, которые мы можем увидеть в консоли↑↑↑ дают нам огромные возможности в работе с событием, доступ к параметрам и настройках события

//Популярные события мыши
//.onclick - клик мышью
//.ondblclick - двойной клик
//.oncontextmenu - клик ПКМ
//.onmousemove - движение мышью
//.onmouseenter и .onmouseleave  - событие на наведение или уход курсора мыши с элемента 

// ↑↑↑ Необходимо знать, что при методе 1 и 2 названия событий имеют приставку on. В то время как при addEventListener - без приставки

const div = document.createElement('div')
document.body.append(div)
div.style.width = '90px'
div.style.background = 'black'
div.style.height = '90px'
div.onmouseenter = () => {
    div.style.background = 'red';
}
div.onmouseleave = () => {
    div.style.background = 'yellow'
}

//.onmousedown - работает, пока мы навели мышку на событие, нажали и держим клавишу



//Метод для условия, если обработчик сработал и он нам уже не нужен
const btn3 = document.querySelector('.b3') //Берем элемент со страницы, на который необходимо повесить событие
let i = 0; //с помощью этой переменной и строки i++ мы ставим определенные рамки, в которых будет происходить функция
const deleteEl = (e) => { //создаем функцию с аргументом е (первый аргумент функция - это объект "событие". Имеется в виду, самый типичный js объект со своими значениями и ключами)

    console.log(e.target); //обращаемся к ключу target в объекте e. (все как в мануале про объекты)
    i++; // i было равно 0, теперь будет равно 1
    if (i == 1) { //создаем условие, что будет если при i == 1
        btn3.removeEventListener('click', deleteEl); //как только i будет равно 1,событие click будет удалено
    }
};
btn3.addEventListener('click', deleteEl)
//__________________________________________________________
//@ Всплытие, погружение, распространение событий (stopPropagation())

// Допустим у нас есть в разметке 2 дива, при чем btn2 находится внутри color
// Проблематика такова, что при нажатии на кнопку мы получаем результат и с кнопки, и с дива.
// Это явление называется "всплытием" события и является нормой для js
const btn = document.querySelector(".btn2")
const div = document.querySelector(".color")

div.addEventListener('click', e => {
    console.log('test div')
}) 

btn.addEventListener('click', e => {
    e.stopPropagation()
    console.log('test btn')
})



// Если нажать на сам div на странице, то в консоль получим test div. Однако, если нажать на кнопку, то получим и сообщение от кнопки, и сообщение от дива, т.к. он является родителем кнопки.
//? чтобы это пресечь, существует метод stopPropagation()
// данный метод мы применяем к параметру колбека при объявлении события, когда вызываем ДОЧЕРНИЙ элемент (в данном случае это btn)
// Данный метод необходимо использовать в случае явного конфликта двух одинаковых событий

//* Проверка элемента на наличия id при клике
//? Пока не понятно. почему не удается такое провернуть с классом или любым другим параметром из списка target в консоли

document.onclick = function(event) {   
    if (event.target.id == 'm') {
        console.log('отслеживание элемента при нажатии по id')
    }
}
//__________________________________________________________
//Код HTML для ↑↑
/*
    <div class="main" id="m">
        <div class="color">
            <button class="btn2">press</button>
        </div>
    </div>
*/
//__________________________________________________________




//@СОБЫТИЯ НА МОБИЛЬНОМ УСТРОЙСТВЕ

//touchstart  - событие при возникновения касания к элементу
//touchmove - при касании палец начинается движение
//touchend - палец оторвался от элемента
//touchenter - когда мы скользим пальцем и попали на границы элемента
//touchleave - палец скользил и ушел за пределы элемента
//touchcancel - палец вышел за пределы браузера

box.addEventListener('touchmove', (e) => {
    e.preventDefault();
    console.log('Move');
})

//У свойства события е (event) есть дополнительные параметры только в сенсорных событиях
//e.touches - отражает какое количество касаний в данный момент
//e.targetTouches - 
//changedTouches - список пальцев, которые участвуют в текущих события.
//?Пальцы, которые совершили назначенное действие

// Берем элемент
const list = document.querySelector('.list')
console.log(list)

// Вешаем на него событие click. 
list.addEventListener('click', (event) => {
console.log(event.target)
})



//@ Вывести на страницу данные из импута по событию

const comments = []

document.querySelector('.btn').onclick = () => {
  input =  document.querySelector('.int').value
   comments.push(input)
   draw()
}

function draw() {
   let out = ''

   for (let i = 0; i < comments.length; i++) {
      out += `<li>${comments[i]}</li>`
   }

   document.querySelector('ul').innerHTML = out
}

