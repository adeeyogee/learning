// React нужен для построения интерфейсов
// react необходим для оптимизации больших проектов. Подключать множество js файлов с приложениями для сайта не эффективною. React позволяет строить сайт кусочками. При правильном использовании кусочки получаются изолированными. Отдельные кусочки называются компонентами. Они имеют законченную функцию. Их можно повторно использовать при необходимости
// Рабочий формат документа реакт - JSX. Файл, позволяющий содержать в себе синтаксис HTML, CSS, JS. Хотя синтаксис и похож на CSS, HTML - все в JSX файле написано на JS коде. JSX - это синтаксическая надстройка над JS.

//! Правила работы с форматом jsx:

//? 1) Существуют пользовательские и встроенные компоненты (div, h1..). Пользовательские компоненты имеют в названии заглавную букву, а встроенные - строчную.
//? 2) Функциональные компонент должен возвращать всегда один родительский элемент

/*
return (
   <h1>Hello</h1>
   <h2>World</h2>
)
*/
//* 3) Данный код является не валидным. Оба тега должны быть "обернуты" в родительский тег <div>
//? 4) Передача свойств (props) является всегда односторонним и работает от родительского компонента к дочернему
//? 5) Состояние (state) должно меняться только в том компоненте, в котором оно было создано.


//@Алгоритм запуска реакт приложения
// В командной строке переходим в ту папку, где будет проект
// npm init [создается package.json] ↓↓↓
//? папку nod_modules необходимо добавить в гит игнор
// npm install create-react-app
// npx create-react-app *имя проекта*
// npm start
//
//



//? Подробное описание шагов установки и запуска.
//! Инициализация приложения NPM
// NPM init
// Создается файл package.json
// Он описывает наши проекты. Также, файл позволяет легко делиться пакетами.
//! Достаточно взять чужой package.json, залить его к себе и выполнить команду npm install. Необходимые пакеты сами скачаются


//@npm install -g create-react-app

//? Данный пакет позволяет компилиовать код в полноценное реакт приложение
// данная команда позволяет установить пакет create-react-app, с помощью которого можно создавать шаблоны для react приложений. флаг -g устанавливает пакет глобально

//@npx create-react-app

//Выполнить данный пакет. Создает шаблон приложения реакт. В результате в терминале должно отобразиться happy hacking, а в рабочей папке создается новая папка *имя проекта*

// Для установки пакета приложения используется команда 
// npm -install -g create
// Флаг -g означает, что http-server должен быть установлен глобально и быть доступными для всех приложений.

//* пока что ↑ это не точно и необходимо углубить знания по npm и npx командам

//@ Удаление локально установленного пакета
// npm uninstall http-server (-g глобально)



//@запускать приложение для разработки необходимо из его папки командой npm start
//C:\js\react\myapp> npm start
// Данный сервер разработки включает в себя различные приложения типа babel, сборщик модулей в бандл и т.д. 

//@ npm run build позволяет создать статическую сборку для отправки на сервер

//@ npm test тестирование отдельных компонент или приложения в целом. Тесты являются нашей прерогативой

//_____________________

//@ Повесить событие на кнопку
//* Событие в react прописывается inline, в отличии от обычной верстки html, css, js 
<button onClick={this.showText}>Push1</button>
//* И еще необходимо создать сам метод, который будет вызывать результат
showText() {
   console.log('showTxt button')
}
// Важно помнить, что события в jsx присваиваются с помощью переменной this (мы ссылаемся на метод)

//?Еще одна возможность события на кнопке с помощью хука 
//когда мы используем хуки, необходимо помнить про синтаксис и функционал события на кнопке
//?хук
//const [run, setRun] = React.useState(false)

//?само событие на кнопке
<button onClick={() => setRun(true)}>Push
</button>


//_____________________

//@ Хук hook

let [count, setCount] = React.useState(0)
//1) объявляем переменную count и функцию setCount  
//2) используем метод useState из библиотеки React. Метод принимает на себя аргумент начального значения состояния. В нашем случаем начальное значение count
//3) Создаем функцию
   const changeData = () => {
       setCount (count + 1)
   }




//@ inline style
// Применение инлайн стилей
//  <footer className="section footer-classic context-dark" style = {{background: "#2d3d46", color: "#fff"}}>
//_____________________

//@ input
// данный элемент пишется в стиле <input /> 

//@ <li> Списки и ключи
// Когда мы выводим данные в списки, реакт просит, чтобы каждому списку мы присваивали ключ. Тогда движок сможет идентифицировать список.
// data.map(el, index) => { return <li key={index.toString()></li>}}
// Параметр index отвечает за индекс элемента в массиве. Методом toString() мы конвертируем значение индекса в строку и таким образом даем движку возможность учитывать списки по индексу.


//@ props & state

// переменные могут объявляться с помощью let
// А использоваться посредством {}
// let a = 42
// <h1>{a}</h1>
// Однако такой метод приведет к тому, что в последующем придется искать переменную по всем компонентам, чтобы ее изменить. 
// Задавать переменные необходимо в единой точке входа, чтобы родительские компоненты могли делиться информацией с дочерними компонентами
// Для этого существует технология props

// 1. Создаем компонент, который будем передавать в пропс
// 2. В самом компоненте с помощью this.props.* (название компонента) передаем его в другой файл, где хотим его вызвать.
// 3. логично было бы передать его в файл, где собраны все компоненты согласно верстки. А оттуда уже передать это пропс с помощью this.props.* в точку входа приложения. И уже там задать значение пропса. Таким образом все будет разложено по своим местам. Верстка компонентов, к примеру, в файле App.js, значение пропсов в главном файле index.js. 

//! главное отличие между props и state - первый мы не меняем  (хотя можем), а второй меняем в процессе

//@ state - это данные в виде объекта внутри компонента, изменение которых приводит к перерисовке компонента.  
//объект this.state = {ключ: "значение"}

//? Цепочка работы со state в рамках замены данных. Рассматривается при нажатии на кнопку.

// 1) создаем state по аналогии с props 
// 2) создаем кнопку и вешаем на нее событие
// 3) в текущем компоненте создаем функцию (метод), при вызове которой будет происходить замена
// 4) В этом методе прописываем конструкцию this.setState({key: 'значение'})
// 5) В данном примере изначально у нас state выглядит так:

this.state = {
   text: "Hello, it's a state component"
   
}

//* касательно присваивания события и вызова метода еще можно почитать непосредственно в компоненте StatePractice. Там указано, как ведет себя this на методе и как правильно делать присваивание.


//@ render() рендер
// условный рендер - рендер исходя из определенного условия
const [open, setOpen] = React.useState(false)
// далее само условие и что конкретно необходимо отрисовать
open && (
//   ****код для отрисовки***
)
//! условие ↑ говорит буквально " open и *код* " Но, если помнить правило оператора И (&&): И всегда останавливается на лжи. Т.е. когда js видит open, он проверяет его значение в хуке. Видит, что там false и условие дальше не выполняется. Таким образом мы блокирует правую часть, где находится рендер.

//