// Классы в Js  - это синтаксическая надстройка над функциями и объектами
// Класс - это шаблон для создания ЭКЗЕМПЛЯРА
// Название класса начинается с заглавной буквы (Pascal case notation)


class Comment {
   constructor (text) { // эта функция может называться только так
      this.text = text
      this.votesQt = 0
   }

   upvote() {   // название метода может быть любым
      this.votesQt += 1
   }
}

// Constructor - функция, в теле которой прописан каркас для постройки новых экз.
// upvote - метод класса. Может быть сколько угодно. Оперируют со значениями, которые мы написали в конструкторе. Они похожи на методы в объектах. Название.параметры.тело метода
// переменная this - специальная переменная, которая указывает на экземпляр класса. Она зависит от контекста, в котором вызвана. В каждом экземпляре контекст будет свой.
// При вызове метода constructor мы передаем значения для параметра text. Внутри этого конструктора мы конкретному экземпляру класса Comment добавляем свойство text, а значение этого свойства будет значение параметра text, которое мы передаем параметром в constructor
// constructor вызывается для того, чтобы создать новую форму для будущих экземпляров
// с помощью ключевого слова new можно создать экземпляр класса

const firstComment = new Comment('First comment')
// создаем новый экз и присваиваем его переменной для дальнейшего вызова.
// с помощью такого синтаксиса ↑↑↑ вызывается функция constructor, и, как описывалось выше, мы передаем аргумент First comment в параметр функции constructor 

//console.log(firstComment) // <prototype>: Object { … } //! НАСЛЕДУЕМЫЕ МЕТОДЫ 
// метод upvote будет унаследованным от родительского класса Comment
//_________________________________________


//@ Расширение классов



class User  {
   constructor(name,secName, clas) {
      this.name = name
      this.secName = secName
      this.clas = clas
   }
   
   logMessage() {
      console.log(`I am ${this.name} ${this.secName} -  ${this.clas}`)
   }

   static staticMethod(x) {   //@ Статический метод. Можно передавать параметры  staticMethod (param)
      alert('i am static' + x) 
   }
}

class Admin extends User {

   constructor(name, secName, dog, clas) {
      super(name, secName, clas)
      this._dog = dog //@ Приватное свойство ↓↓↓
   }

   logMessage2() {
      console.log(`I am ${this.name} ${this.secName} - ${this.dog}${this.clas}`)
   }
}

const out1 = new User('Vadim', 'Gold', 'User')
const out2 = new Admin('Vasil','Born', '@', 'Admin' )

// out1.logMessage()
// out2.logMessage2()



//@ Статические методы
// К ним можно обращаться напрямую, без создания экземпляра
// User.staticMethod()
// как правило, это сервисные методы
//console.log(User.staticMethod(10))


//@ Геттеры и Сеттеры
// Существует соглашение, согласно которому свойства с _ принято считать приватными и их лучше не изменять, чтобы код не посыпался 
//  this._dog = dog

//* Чтобы поменять свойство:
//out2._dog = 2
// Обращаемся к переменной ик нужному нам свойству

// class Test {
//    constructor (one, two) {
//       this._one = one
//       this._two = two
//    }

//    get one() { //@ getter. Получатель свойства. 
//       return this.one
//    }
   
//    set one(x) { //@setter. Установщик
//       this._one = x
//    }

// }
//!  ↑↓
// Таким образом, используя геттер, мы обращаемся к свойству не напрямую, а через посредника. В теле геттера могут быть проверки, преобразователи, дополнительные теги и т.д. Свойство будет защищено
// Интерпретатор будет просматривать объект и искать метод с приставкой get, если он есть, то он выполняется
// Теперь необходимо присвоить значение (или изменить существующее) свойству
//Test.one = 'GGG'
// Сеттер дает возможность перед сохранением сделать проверки и другие манипуляции со свойством
//console.log(Test.one)


//@ Прототипное наследование
// Если прописать firstComment. то после точки будут видны все методы, которые доступны этому объекту
// 1) Его личные методы text и votesQty (на уровне этого объекта)
// 2) На уровне родительского класса Comment будут доступны constructor и upvote
// 3) Остальные методы объекта (isPrototypeOf, valueOf и т.д.). Они видны, потому что Comment наследует все методы и свойства Объекта, а Object - это класс, которые присутствует по умолчанию

const a = {
   keyOne: 'first key', //! ↓
   keyTwo: 'second key',
   keyThree: function() {
      console.log(this.testKey) //@ Переменная this ссылается не на тот объект, в котором она прописана, а на тот в котором она ВЫЗВАНА.
   },
   testKey: 'testkey of object a', 
}

const b = {
   key1: '1st',
   key2: '2nd',
   testKey: 'testkey of object b'
}

// console.log(a)
// console.log(b)


// b.__proto__ = a //@ объект b наследуется от а
// такай синтаксис является устаревшим

//*Object.setPrototypeOf(obj, prototype)  современный синтаксис (дочерний, родительский)
Object.setPrototypeOf(b, a)

 
//console.log(b.keyOne) //!  ↑ Все свойства объекта а стали доступны для объекта b
// Таким же образом можно наследовать и методы объекта
//console.log(a.keyThree())
//!  1)   в объекте b не существует функции, но так как происходит прототипное наследование по цепочке, интерпретатор находит такую функцию в объекте а
//!  2)  в функции объекта а идет вызов ключа из объекта b  с помощью переменной this. 
//!  3) свой контекст переменная this приобретает в момент вызова. Вызываем мы этой строкой console.log(b.keyThree()).
//!  4) Таким образом, суть всего этого наследования в следующем. У нас был какой-то объект а, нам потребовался новый объект b, но с другими свойствами и ключами (в данном примере это testKey). В объекте а у нас был метод вызова этого ключа. Чтобы не создавать еще один метод в объекте b, мы унаследовались от объекта а и применили нужный нам метод.
//!  5) Переменная this в функции делает наш метод универсальным, позволяет использовать данный метод для будущих объектов с, d, e и т.д.

// Когда мы наследуемся,то можем обращаться к любим свойствам и методам
// Вы мы создали цепочку наследования (Object.setPrototypeOf(b, a))
// Допустим нам необходимо из объекта b обратиться к свойству объекта а, но ключи этих свойств совпадают. Для этого есть синтаксис
console.log(b.__proto__.testKey)
// свойство testkey у нас есть в обоих объектах. Мы обратились к нужному нам.









