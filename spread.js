//@ spread и rest операторы
// данный оператор используется ддя того, чтобы разбить одну строку, массив, объект на несколько. 

let s1 = [1,2,3]
let s2 = [55,33,...s1]
console.log(s2) // [ 55, 33, 1, 2, 3 ]

//@ ...spread  синтаксис

//? 1. для создания поверхностных копий

let s3 = [...s1] // s3 - копия массива s1. При чем это действительно новый адрес в памяти и дублирование значений,а не просто копирование ссылки (s1 или s3). Если изменить массив s1, то новый массив s3 не изменится.


//? 2. Конкатенация

let a = [100, 200]
let b = [66, 44]
let s4 = [...b,...a] // новый массив, который нагружает память и влияет на быстродействие. Это не всегда уместно.
console.log(s4)

//? Эмуляция unshift() (Добавление элемента в начало массива)

let s5 = [111, ...a]
console.log(s5)

//? Преобразование nodList коллекции

let p = document.querySelector('.someClass')
// Если к p применить метод массива, то будет ошибка. p не является массивом.
// spread позволяет сделать преобразование
p = [...p]

//? Удаление дублей

let s6 = [1,1,1,1,1,2,3,4,5,6]
let s7 = [...new Set(s6)]
console.log(s7)

//? Применение к строке

let str1 = 'adi'
let str2 = [...str1]
console.log(str2) // создан новый массив, каждым элементом которого является символом из строки


//? Применение к объектам

let o1 = {name: 'test1', age: '19'}
let o2 = {name: 'test2', age: '20'}

let o3 = {...o1,...o2}
console.log(o3) // { name: 'test2', age: '20' }
//! т.к. в разных объектах есть свойства с одинаковым названием, то движок перезаписывает свойства, когда доходит до ...o2. Важен порядок записи в объект o3.


//? Добавление свойств в объект

let o4 = {...o1, secondName: 'da'}
console.log(o4)
//________________________________________________________


//@ rest... параметр 
// собирает воедино в новый массив
// Подход spread синтаксиса, который применяется в функции в качестве параметра ( и называется при этом rest, хотя синтаксис такой же) для того, чтобы собрать данные и поместить их в массив

function f1(a,...b) {
    console.log(a) // 1
    console.log(b) // [ 2, 3, 4, 5, 6 ]
}
f1(1,2,3,4,5,6)
// все аргументы, которые не попадут в а, попадают в массив b