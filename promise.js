// promise - обещание предоставить результат позже
// promise - объект
// promise исполнен - вернут результат, promise отклонен - вернулась ошибка. Других состояний нет
// Данная технология дает возможность js обрабатывать отложенные во времени события. К примеру, какой-то запрос на сервер, и не известно, когда сервер ответит. Чтобы сайт продолжал дальше загружать элементы и пользователь мог с ним взаимодействовать, существует такая технология. Это асинхронный запрос (запрос был отправлен, но ответ приходит не сразу, а спустя время)
 //Promise.all - счетчик, который дожидается выполнения каждого промиса возвращает их результаты. 


// Создается новый экземпляр класса Promise (он есть по умолчанию)
const myPromise = new Promise((resolve, reject) => { // resolve, reject являются обязательными параметрами
   //* Это тело коллбек функции. Тут необходимо вызвать либо функцию resolve, либо reject
   //! Данным кодом мы объявляем переменную, кладем в нее новый промис, делаем определенный запрос в теле промиса.
})

// У объекта myPromise будет доступно 2 метода: 
//! Код ниже говорит, что делать в двух случаях

myPromise
   .then (value => { //@ В данный параметр попадет то, что мы передавали в параметр resolve.
      //* В качестве аргумента передается функция. В данном случае это стрелочная функция с одним параметром. 
      //!Выполняется в случае успеха. Тут мы описываем логику возврата данных. (Что-то перезаписать в базе данных и тд.)
   })
   .catch (error => { //@ Тот, аргумент, с которым была вызвана функция внутри промиса и будет = error
      //* Что будет выполняться в случае неудачи
   })


//fetch - команда отправки запроса на сервер. Возвращает промис. Какое-то время он будет в состоянии pending и ни одна из функций ниже не будет вызвана
//Для удобства и тестов обычно пользуются сервисом https://jsonplaceholder.typicode.com/ чтобы не создавать свой сервер

/*
fetch('https://jsonplaceholder.typicode.com/todos')  Тут мы просто запускаем запрос серверу, но чтобы получить данные и работать с ними дальше, необходим код ниже
   .then(response => response.json()) //* вызовется в случае успешного запроса. При чем данные, которые будут приходить с сервера, они могут быть разные, может избыточные. Для этого мы вызываем метод json(), который распарсит нам результат в формат json ↓↓↓
   .then(json => console.log(json)) //* Именно поэтому ↑↑↑ мы вызываем по цепочке методы, чтобы получить данные в нужно нам формате. А именно объект js
   .catch(error => console.log(error)) //* данный метод стоит на случай, если один из промисов вернет ошибку (не получилось распарсить, нет интернета, сервер не работает итд)

   //! fetch и json возвращают промис

*/

fetch('https://jsonplaceholder.typicode.com/todos')
   .then(response => {
      console.log(response)
      return response.json()
   })
   .then(json => console.log(json))
   .catch(error => console.log(error))




//___________________________________________________




//@ Async Await

const f1 = function() {
   fetch('https:*')
   .then(response => response.json())
   .then(json => console.log(json))
   .catch(err => console.log(err))
}
const f2 = () => {
   console.log(2)
}
const f3 = function() {
   console.log(3)
} 

f1()
f2()
f3()


// результат вызова функции 1 будет последним, т.к. время выполнения ф2 и ф3 гораздо быстрее, чем запрос на удаленный сервер и возврат данных
// Функция ф1 построена на архитектуре промиса. Более компактно и современно можно сделать с помощью async await функции

async function f4() {
   const result = await fetch('https://*')
   return result.text()
}

// объявляем асинхронную функцию
// помещаем в переменную будущий результат запроса на сервер
//? возвращаем данные с методом,удобным для нас (или только text() доступен. Пока не ясно)

// Из-за того, что наша функция помечена как async, ее необходимо вызывать не просто f1() а особым образом

async function x () {
   let a = await f4()

   //* В данной функции вызова асинхронных запросов мы можем указать порядок, в каком нпи удобно выводить данные. К тому же, мы можем передавать данные из функции f4 в такую же async функцию f5() и т.д. Однако, такой вызов по цепочке и работа с результатом уместна тогда, когда данные зависят друг от друга. Если данные независимы, то лучше не связывать функции друг с другом, чтобы добиться более высокой скорости выполнения скрипта
}

// Таким образом, мы как будто соединяем в цепочку наш запрос (в виде функции f4()) и наш вызов этого запроса на сайте (в виде функции x() )