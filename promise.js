// promise - обещание предоставить результат позже
// promise - объект
// promise исполнен - вернут результат, promise отклонен - вернулась ошибка. Других состояний нет
// Данная технология дает возможность js обрабатывать отложенные во времени события. К примеру, какой-то запрос на сервер, и не известно, когда сервер ответит. Чтобы сайт продолжал дальше загружать элементы и пользователь мог с ним взаимодействовать, существует такая технология. Это асинхронный запрос (запрос был отправлен, но ответ приходит не сразу, а спустя время)
 //Promise.all - счетчик, который дожидается выполнения каждого промиса возвращает их результаты. 


// Создается новый экземпляр класса Promise (он есть по умолчанию)
const myPromise = new Promise((resolve, reject) => { // resolve, reject являются обязательными параметрами
   //* Это тело коллбек функции. Тут необходимо вызвать либо функцию resolve, либо reject
   //! Данным кодом мы объявляем переменную, кладем в нее новый промис, делаем определенный запрос в теле промиса.
})

// У объекта myPromise будет доступно 2 метода: 
//! Код ниже говорит, что делать в двух случаях

myPromise
   .then (value => { //@ В данный параметр попадет то, что мы передавали в параметр resolve.
      //* В качестве аргумента передается функция. В данном случае это стрелочная функция с одним параметром. 
      //!Выполняется в случае успеха. Тут мы описываем логику возврата данных. (Что-то перезаписать в базе данных и тд.)
   })
   .catch (error => { //@ Тот, аргумент, с которым была вызвана функция внутри промиса и будет = error
      //* Что будет выполняться в случае неудачи
   })


//fetch - команда отправки запроса на сервер. Возвращает промис. Какое-то время он будет в состоянии pending и ни одна из функций ниже не будет вызвана
//Для удобства и тестов обычно пользуются сервисом https://jsonplaceholder.typicode.com/ чтобы не создавать свой сервер

/*
fetch('https://jsonplaceholder.typicode.com/todos/2')  Тут мы просто запускаем запрос серверу, но чтобы получить данные и работать с ними дальше, необходим код ниже
   .then(response => response.json()) //* вызовется в случае успешного запроса. При чем данные, которые будут приходить с сервера, они могут быть разные, может избыточные. Для этого мы вызываем метод json(), который распарсит нам результат в формат json ↓↓↓
   .then(json => console.log(json)) //* Именно поэтому ↑↑↑ мы вызываем по цепочке методы, чтобы получить данные в нужно нам формате. А именно объект js
   .catch(error => console.log(error)) //* данный метод стоит на случай, если один из промисов вернет ошибку (не получилось распарсить, нет интернета, сервер не работает итд)

   //! fetch и json возвращают промис

*/

const request = fetch('https://jsonplaceholder.typicode.com/todos/3', {
      method: 'get'
})
      request.then(response => response.json())
      request.then(json => console.log(json))
      request.catch(error => console.log(error))
//___________________________________________________




//@ Async Await
//Данные функции - это всего лишь специальный синтаксис для написания промисов
//Асинхронная функция возвращает промис

const f1 = function() {
   fetch('https:*')
   .then(response => response.json())
   .then(json => console.log(json))
   .catch(err => console.log(err))
}
const f2 = () => {
   console.log(2)
}
const f3 = function() {
   console.log(3)
} 

f1()
f2()
f3()


// результат вызова функции 1 будет последним, т.к. время выполнения ф2 и ф3 гораздо быстрее, чем запрос на удаленный сервер и возврат данных
// Функция ф1 построена на архитектуре промиса. Более компактно и современно можно сделать с помощью async await функции

async function f4(url) {
   const result = await fetch(url)
   const json = result.json()
   return console.log(json)
}

// объявляем асинхронную функцию
// помещаем в переменную будущий результат запроса на сервер
// парсим результат в объект json
// возвращаем данные


//@ Синтаксис написания асинхронных стрелочных функций

const request2 = async (url) => {
   const result = await fetch(url)
   const json = await result.json()
   return console.log(json)
}
request2('https://jsonplaceholder.typicode.com/todos/2')