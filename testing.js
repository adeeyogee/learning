// Тесты - неотъемлемая часть разработки. Тестированию должно подвергаться все: начиная конкретной фун и заканчивая приложением в целом.
// Виды тестирования: 
// Unit. Тестируется конкретная функция в изолированной среде. Остальные компоненты приложения не принимают участия и не влияют на работу функции. (можем тестировать функцию, метод, класс). Если есть какие-либо зависимости, то мы их имитируем (Мокаем)
// Integration test. В данном тесте зависимость присутствует и она не имитируется. Таким образом мы проверяем, как модуль работает в паре с другим модулем 
// End to End test. - Тестируется часть приложения или полностью. Функции кнопок и других элементов интерфейса. Тестируется не код,а внешнее поведение

const { default: test, describe, it } = require("node:test")
const filterArray = require("../testing/task/task_02")

//@ Пирамида тестов

//          E2E         // - дорогие медленные тесты, которые присутствуют в крупных проектах
//      Integration     // - такие тесты присутствуют, менее быстрые
//          Unit        //- таких тестов больше всего в проекте. Они самые быстрые


//? Библиотека Unit тестирования jest (создаем скрипты с ожидаемым значение и запускаем их с необходимыми параметрами. Смотри как работает функция и что она возвращает)

//? Библиотека Integration и E2E тестирования puppeteer (позволяет запустить браузер и выполнять фиктивные клики, отслеживать реакции на события вместо ручного использования юзером)

//@ Jest. Алгоритм инициализации пакета и импортирования тестируемой функции.

// npm init
// npm i jest
// в package.json после dependencies необходимо добавить  
//?  "scripts": {
//?     "test": "jest"
//? }
// с помощью какой команды мы будем запускать тестирование ↑ (test)
//! создаем сам файл тестирования reverse_string.test.js
// Используя модули, экспортируем код, который необходимо тестировать. module.exports = reverseString
//! В файле теста импортируем код. const reverseString = require('./task/task_01')
// Можем писать тесты ↓↓↓
// После того, как тест написан, в терминале можем его запустить: npm test (при чем test мы сами указали, когда добавляли скрипт в package.json)
//? Если тестов много, то можем указать, какой именно запускать (npm test .\filterArray.test.js)


//* Разбор на примере функции, которая разворачивает строку.

function reverseString(str) {
    let str2 = str.split('')
                    .sort(() => Infinity)
                        .join('')
    console.log(str2) //?
    return str2
}

//! 1 тест. Данный тест построен на методе toBe - в этом методе мы задаем то значение, которое должно быть. Он используется для сравнения примитивов

//Первым параметром идет название теста. 2 - функция, которая будет прогонять тест, 3 - сколько миллисекунд ждать ответа (если тестируем асинхронный код)

test(
    'проверяем реверс строки',
    () => {
        expect(reverseString('hello')).toBe('olleh')
    }
)


// Служебная команда test
// Внутри создаем функцию, которая вызывает служебный метод expect
// Этот метод вызывает с параметром проверяемой нами функцией
// При чем, наша функция также получает параметр, т.к. это и есть суть тестирования
// метод toBe принимает параметр значение, которое должно быть в результате выполнения нашей функции. Не именно, как логически или математически правильно, а как мы укажем, так и будет "правильно"


//* Когда мы получаем проект, то перед началом кодирования, продумываем тесты. Как описывалось выше, таких тестов (Unit) в проекте больше всего. Чтобы не выписывать каждый тест по отдельности, можем создать test case, в котором просто укажем ключи.

// Служебная команда describe
// 1 аргумент - название кейса
// 2 аргумент - функция, которая возвращает массив объектов с ключами теста
// Дальше идет перебор с помощью forEach. Т.е. на каждый объект будет выполняться функция (а именно test(еще можно написать it)). Таким образом, мы создаем только один тест, но подставлять в него можем сколько угодно аргументов. 
// Собственно, функция (коллбек), который будет применяться на каждой итерации - это test (it)
// Добавили описание первым аргументом
// Вторым аргументом создаем функцию, которая будет проводить тест.
//? В этой функции объявляем переменную  и присваиваем ей то, что будет аргументом при вызове нашей (базовой) функции, которую мы тестируем. По сути, мы взяли эту строку expect(reverseString('hello')).toBe('olleh') из примера выше и положили в переменную первую ее часть (expect(reverseString('hello')))
//
//
const reverseString = require('./task/task_01') // импорт кода, который необходимо проверить

describe(
    'проверка реверса строки',
    () => {
        const testCase = [
            {
                inString: 'dog',
                expected: 'god'
            },
            {
                inString: 'for the Emperor',
                expected: 'rorepmE eht rof'
            },
            {
                inString: 'yellow',
                expected: 'wolley'
            }
        ]
        testCase.forEach((test) => {
            it ( // тут по аналогии, как с test в примере выше, только описание более продвинутое
                `Входящая строка: ${test.inString} ожидаю: ${test.expected}`,
                () => {
                    const res = reverseString(test.inString)
                    expect(res).toBe(test.expected)
                }
            )
        })
    })
//_________________________________________

//! 2 тест. toEqual. Данный метод используется для сравнения объектов и массивов
// 1 аргумент - название
// 2 аргумент - функция тестирования, в которой находятся test cases
//
//

const arrayFilter = require('./task/task_02') // импортируем код, который необходимо проверить
describe(
    'Фильтр массива',
    () => {
        const testCase = [
            {
                in: [0,1,2,3,4],
                expected: [0,2,4]
            },
            {
                in: [true,false,true,false,true,false],
                expected: [true, true, true]
            },
        ]
        testCase.forEach((test) => {
            it(
                `in: ${test.in} expected: ${test.expected}`,
                () => {
                    const res = arrayFilter(test.in) //* Напоминание [чтобы тест работал,в него необходимо импортировать проверяемый код]
                    expect(res).toEqual(test.expected)
                }
            )
        })
    }
)

//_________________________________________

//! 3 тест. Сравнение диапазонов. toBeGreaterThanOrEqual - ожидаю, что переменная будет больше или равна значения из тест кейса (или toBeLessThanOrEqual)

const randomInt = require('./task/task_03')

describe(
    'Тестируем случайное число',
    () => {
        const testCase = [
            {
                from: 100,
                to: 110
            },
            {
                from: 200,
                to: 201
            }
        ]
        testCase.forEach((test) => {
            it(
                `from: ${test.from} to: ${test.to}`,
                () => {
                    const res = randomInt(test.from, test.to)
                    expect(res).toBeGreaterThanOrEqual(test.from)
                    expect(res).toBeLessThanOrEqual(test.to)
                }
            )
        })
    }
)

//! Данный тест не работает. Необходимо углубить знания и разобраться, почему вместо значения to возвращает NAN.